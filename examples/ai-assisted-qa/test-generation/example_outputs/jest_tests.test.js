/**
 * Example Output: AI-Generated Jest Tests
 * Generated by AITestGenerator for email validation function
 *
 * This demonstrates AI-generated JavaScript/TypeScript tests using Jest
 */

// Source function being tested
function validateEmail(email) {
  if (typeof email !== 'string') {
    throw new TypeError('Email must be a string');
  }

  if (!email || email.trim() === '') {
    return false;
  }

  // Basic email regex
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;

  // Additional validation rules
  if (email.length > 254) {
    return false; // RFC 5321
  }

  if (!emailRegex.test(email)) {
    return false;
  }

  // Check for invalid characters
  if (email.includes('..')) {
    return false; // No consecutive dots
  }

  return true;
}

// ============================================================================
// AI-GENERATED TESTS BELOW
// ============================================================================

describe('validateEmail', () => {
  describe('Happy Path - Valid Emails', () => {
    test('should accept standard email format', () => {
      // Arrange
      const email = 'user@example.com';

      // Act
      const result = validateEmail(email);

      // Assert
      expect(result).toBe(true);
    });

    test('should accept email with subdomain', () => {
      // Arrange
      const email = 'user@mail.example.com';

      // Act
      const result = validateEmail(email);

      // Assert
      expect(result).toBe(true);
    });

    test('should accept email with numbers', () => {
      // Arrange
      const email = 'user123@example456.com';

      // Act
      const result = validateEmail(email);

      // Assert
      expect(result).toBe(true);
    });

    test('should accept email with dots in local part', () => {
      // Arrange
      const email = 'first.last@example.com';

      // Act
      const result = validateEmail(email);

      // Assert
      expect(result).toBe(true);
    });

    test('should accept email with hyphens', () => {
      // Arrange
      const email = 'user-name@my-company.com';

      // Act
      const result = validateEmail(email);

      // Assert
      expect(result).toBe(true);
    });

    test('should accept email with plus sign', () => {
      // Arrange
      const email = 'user+tag@example.com';

      // Act
      const result = validateEmail(email);

      // Assert
      expect(result).toBe(true);
    });

    test('should accept email with underscore', () => {
      // Arrange
      const email = 'user_name@example.com';

      // Act
      const result = validateEmail(email);

      // Assert
      expect(result).toBe(true);
    });

    test('should accept email with multiple subdomains', () => {
      // Arrange
      const email = 'user@mail.dept.company.com';

      // Act
      const result = validateEmail(email);

      // Assert
      expect(result).toBe(true);
    });

    test('should accept email with two-letter TLD', () => {
      // Arrange
      const email = 'user@example.co';

      // Act
      const result = validateEmail(email);

      // Assert
      expect(result).toBe(true);
    });

    test('should accept email with long TLD', () => {
      // Arrange
      const email = 'user@example.museum';

      // Act
      const result = validateEmail(email);

      // Assert
      expect(result).toBe(true);
    });
  });

  describe('Invalid Emails', () => {
    test('should reject email without @', () => {
      // Arrange
      const email = 'userexample.com';

      // Act
      const result = validateEmail(email);

      // Assert
      expect(result).toBe(false);
    });

    test('should reject email without domain', () => {
      // Arrange
      const email = 'user@';

      // Act
      const result = validateEmail(email);

      // Assert
      expect(result).toBe(false);
    });

    test('should reject email without local part', () => {
      // Arrange
      const email = '@example.com';

      // Act
      const result = validateEmail(email);

      // Assert
      expect(result).toBe(false);
    });

    test('should reject email without TLD', () => {
      // Arrange
      const email = 'user@example';

      // Act
      const result = validateEmail(email);

      // Assert
      expect(result).toBe(false);
    });

    test('should reject email with spaces', () => {
      // Arrange
      const email = 'user name@example.com';

      // Act
      const result = validateEmail(email);

      // Assert
      expect(result).toBe(false);
    });

    test('should reject email with multiple @ symbols', () => {
      // Arrange
      const email = 'user@@example.com';

      // Act
      const result = validateEmail(email);

      // Assert
      expect(result).toBe(false);
    });

    test('should reject email with consecutive dots', () => {
      // Arrange
      const email = 'user..name@example.com';

      // Act
      const result = validateEmail(email);

      // Assert
      expect(result).toBe(false);
    });

    test('should reject email starting with dot', () => {
      // Arrange
      const email = '.user@example.com';

      // Act
      const result = validateEmail(email);

      // Assert
      expect(result).toBe(false);
    });

    test('should reject email ending with dot', () => {
      // Arrange
      const email = 'user.@example.com';

      // Act
      const result = validateEmail(email);

      // Assert
      expect(result).toBe(false);
    });

    test('should reject plaintext (not an email)', () => {
      // Arrange
      const email = 'notanemail';

      // Act
      const result = validateEmail(email);

      // Assert
      expect(result).toBe(false);
    });
  });

  describe('Edge Cases', () => {
    test('should reject empty string', () => {
      // Arrange
      const email = '';

      // Act
      const result = validateEmail(email);

      // Assert
      expect(result).toBe(false);
    });

    test('should reject whitespace-only string', () => {
      // Arrange
      const email = '   ';

      // Act
      const result = validateEmail(email);

      // Assert
      expect(result).toBe(false);
    });

    test('should handle string with leading whitespace', () => {
      // Arrange
      const email = ' user@example.com';

      // Act
      const result = validateEmail(email);

      // Assert
      // After trim(), should be valid
      expect(result).toBe(false); // Current implementation rejects
    });

    test('should handle string with trailing whitespace', () => {
      // Arrange
      const email = 'user@example.com ';

      // Act
      const result = validateEmail(email);

      // Assert
      expect(result).toBe(false); // Current implementation rejects
    });

    test('should reject extremely long email (> 254 chars)', () => {
      // Arrange
      const localPart = 'a'.repeat(200);
      const email = `${localPart}@example.com`;

      // Act
      const result = validateEmail(email);

      // Assert
      expect(result).toBe(false); // Exceeds RFC 5321 limit
    });

    test('should accept email at exact length limit (254 chars)', () => {
      // Arrange
      // Create email exactly 254 characters
      const localPart = 'a'.repeat(240); // 240 + @ + example.com (13) = 254
      const email = `${localPart}@example.com`;

      // Act
      const result = validateEmail(email);

      // Assert
      expect(result).toBe(true);
    });

    test('should reject email one character over limit (255 chars)', () => {
      // Arrange
      const localPart = 'a'.repeat(241); // 241 + @ + example.com = 255
      const email = `${localPart}@example.com`;

      // Act
      const result = validateEmail(email);

      // Assert
      expect(result).toBe(false);
    });

    test('should handle single character local part', () => {
      // Arrange
      const email = 'a@example.com';

      // Act
      const result = validateEmail(email);

      // Assert
      expect(result).toBe(true);
    });

    test('should handle single character domain', () => {
      // Arrange
      const email = 'user@a.com';

      // Act
      const result = validateEmail(email);

      // Assert
      expect(result).toBe(true);
    });

    test('should handle numeric TLD', () => {
      // Arrange
      const email = 'user@example.123';

      // Act
      const result = validateEmail(email);

      // Assert
      expect(result).toBe(true); // Technically valid by regex
    });
  });

  describe('Type Validation', () => {
    test('should throw TypeError when passed number', () => {
      // Arrange
      const input = 12345;

      // Act & Assert
      expect(() => {
        validateEmail(input);
      }).toThrow(TypeError);
      expect(() => {
        validateEmail(input);
      }).toThrow('Email must be a string');
    });

    test('should throw TypeError when passed null', () => {
      // Arrange
      const input = null;

      // Act & Assert
      expect(() => {
        validateEmail(input);
      }).toThrow(TypeError);
    });

    test('should throw TypeError when passed undefined', () => {
      // Arrange
      const input = undefined;

      // Act & Assert
      expect(() => {
        validateEmail(input);
      }).toThrow(TypeError);
    });

    test('should throw TypeError when passed object', () => {
      // Arrange
      const input = { email: 'user@example.com' };

      // Act & Assert
      expect(() => {
        validateEmail(input);
      }).toThrow(TypeError);
    });

    test('should throw TypeError when passed array', () => {
      // Arrange
      const input = ['user@example.com'];

      // Act & Assert
      expect(() => {
        validateEmail(input);
      }).toThrow(TypeError);
    });

    test('should throw TypeError when passed boolean', () => {
      // Arrange
      const input = true;

      // Act & Assert
      expect(() => {
        validateEmail(input);
      }).toThrow(TypeError);
    });
  });

  describe('Security & Special Characters', () => {
    test('should reject email with SQL injection attempt', () => {
      // Arrange
      const email = "admin'--@example.com";

      // Act
      const result = validateEmail(email);

      // Assert
      expect(result).toBe(false);
    });

    test('should reject email with XSS attempt', () => {
      // Arrange
      const email = '<script>alert("xss")</script>@example.com';

      // Act
      const result = validateEmail(email);

      // Assert
      expect(result).toBe(false);
    });

    test('should reject email with null byte', () => {
      // Arrange
      const email = 'user\x00@example.com';

      // Act
      const result = validateEmail(email);

      // Assert
      expect(result).toBe(false);
    });

    test('should handle Unicode characters', () => {
      // Arrange
      const email = 'user@mÃ¼nchen.de';

      // Act
      const result = validateEmail(email);

      // Assert
      expect(result).toBe(true); // Unicode domains are valid
    });

    test('should handle emoji in email', () => {
      // Arrange
      const email = 'userðŸ˜€@example.com';

      // Act
      const result = validateEmail(email);

      // Assert
      expect(result).toBe(false); // Emoji not valid in email
    });
  });
});

// ============================================================================
// PARAMETERIZED TESTS WITH TEST.EACH
// ============================================================================

describe('validateEmail - Parameterized Tests', () => {
  describe('Valid Emails', () => {
    test.each([
      ['user@example.com'],
      ['first.last@example.com'],
      ['user+tag@example.com'],
      ['user_name@example.com'],
      ['user-name@example.com'],
      ['123@example.com'],
      ['user@sub.example.com'],
      ['user@example.co.uk'],
      ['a@b.c'],
    ])('should accept valid email: %s', (email) => {
      expect(validateEmail(email)).toBe(true);
    });
  });

  describe('Invalid Emails', () => {
    test.each([
      [''],
      ['   '],
      ['notanemail'],
      ['@example.com'],
      ['user@'],
      ['user'],
      ['user@.com'],
      ['user..name@example.com'],
      ['user @example.com'],
      ['user@example com'],
      ['user@@example.com'],
    ])('should reject invalid email: %s', (email) => {
      expect(validateEmail(email)).toBe(false);
    });
  });

  describe('Type Errors', () => {
    test.each([
      [null],
      [undefined],
      [123],
      [true],
      [false],
      [{}],
      [[]],
      [() => {}],
    ])('should throw TypeError for non-string: %p', (input) => {
      expect(() => validateEmail(input)).toThrow(TypeError);
    });
  });
});

// ============================================================================
// SNAPSHOT TESTS (for consistent behavior documentation)
// ============================================================================

describe('validateEmail - Snapshot Tests', () => {
  test('should maintain consistent validation results', () => {
    const testCases = [
      'valid@example.com',
      'invalid@',
      '',
      'user@sub.example.com',
      'user..name@example.com',
    ];

    const results = testCases.map(email => ({
      email,
      isValid: validateEmail(email),
    }));

    expect(results).toMatchSnapshot();
  });
});

// ============================================================================
// PERFORMANCE TESTS
// ============================================================================

describe('validateEmail - Performance', () => {
  test('should validate email quickly', () => {
    // Arrange
    const email = 'user@example.com';
    const iterations = 10000;

    // Act
    const startTime = performance.now();
    for (let i = 0; i < iterations; i++) {
      validateEmail(email);
    }
    const endTime = performance.now();

    // Assert
    const avgTime = (endTime - startTime) / iterations;
    expect(avgTime).toBeLessThan(0.1); // Should be < 0.1ms per call
  });

  test('should handle long email efficiently', () => {
    // Arrange
    const longEmail = 'a'.repeat(250) + '@example.com';

    // Act
    const startTime = performance.now();
    validateEmail(longEmail);
    const endTime = performance.now();

    // Assert
    const executionTime = endTime - startTime;
    expect(executionTime).toBeLessThan(10); // Should complete in < 10ms
  });
});

// Export for use in other test files if needed
module.exports = { validateEmail };
