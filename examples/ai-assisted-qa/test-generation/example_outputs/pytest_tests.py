"""
Example Output: AI-Generated Pytest Tests
Generated by AITestGenerator for calculate_discount function

This file demonstrates the quality and comprehensiveness of
AI-generated tests using GPT-4.
"""

import pytest
from decimal import Decimal


# Source function being tested
def calculate_discount(price, discount_percent, member_tier="regular"):
    """
    Calculate discounted price based on percentage and member tier

    Args:
        price: Original price (must be positive)
        discount_percent: Discount percentage (0-100)
        member_tier: Member tier (regular, silver, gold)

    Returns:
        Final price after discount and tier bonus
    """
    if price < 0:
        raise ValueError("Price cannot be negative")

    if discount_percent < 0 or discount_percent > 100:
        raise ValueError("Discount must be between 0 and 100")

    tier_bonuses = {
        "regular": 0,
        "silver": 5,
        "gold": 10
    }

    if member_tier not in tier_bonuses:
        raise ValueError(f"Invalid member tier: {member_tier}")

    # Apply discount
    discounted = price * (1 - discount_percent / 100)

    # Apply tier bonus
    tier_bonus = tier_bonuses[member_tier]
    final_price = discounted * (1 - tier_bonus / 100)

    return round(final_price, 2)


# ============================================================================
# AI-GENERATED TESTS BELOW
# ============================================================================

class TestCalculateDiscountHappyPath:
    """Test happy path scenarios for calculate_discount function"""

    def test_regular_tier_with_zero_discount(self):
        """
        Test that regular tier member with 0% discount pays full price

        Arrange: Set price=$100, discount=0%, tier=regular
        Act: Calculate discounted price
        Assert: Price remains $100.00 (no discount or tier bonus)
        """
        # Arrange
        price = 100.0
        discount_percent = 0
        member_tier = "regular"

        # Act
        result = calculate_discount(price, discount_percent, member_tier)

        # Assert
        assert result == 100.0
        assert isinstance(result, float)

    def test_regular_tier_with_discount(self):
        """
        Test regular tier member with standard discount

        Arrange: Set price=$100, discount=20%, tier=regular
        Act: Calculate discounted price
        Assert: Price is $80.00 (20% off, no tier bonus)
        """
        # Arrange
        price = 100.0
        discount_percent = 20
        member_tier = "regular"

        # Act
        result = calculate_discount(price, discount_percent, member_tier)

        # Assert
        assert result == 80.0

    def test_silver_tier_with_discount(self):
        """
        Test silver tier member with discount and tier bonus

        Arrange: Set price=$100, discount=20%, tier=silver
        Act: Calculate discounted price
        Assert: Price is $76.00 (20% off = $80, then 5% tier bonus = $76)
        """
        # Arrange
        price = 100.0
        discount_percent = 20
        member_tier = "silver"

        # Act
        result = calculate_discount(price, discount_percent, member_tier)

        # Assert
        assert result == 76.0

    def test_gold_tier_with_discount(self):
        """
        Test gold tier member with discount and maximum tier bonus

        Arrange: Set price=$100, discount=20%, tier=gold
        Act: Calculate discounted price
        Assert: Price is $72.00 (20% off = $80, then 10% tier bonus = $72)
        """
        # Arrange
        price = 100.0
        discount_percent = 20
        member_tier = "gold"

        # Act
        result = calculate_discount(price, discount_percent, member_tier)

        # Assert
        assert result == 72.0

    def test_maximum_discount(self):
        """
        Test that 100% discount results in zero price

        Arrange: Set price=$100, discount=100%, tier=regular
        Act: Calculate discounted price
        Assert: Price is $0.00
        """
        # Arrange
        price = 100.0
        discount_percent = 100
        member_tier = "regular"

        # Act
        result = calculate_discount(price, discount_percent, member_tier)

        # Assert
        assert result == 0.0


class TestCalculateDiscountEdgeCases:
    """Test edge cases and boundary conditions"""

    def test_zero_price(self):
        """
        Test calculation with zero price

        Arrange: Set price=$0
        Act: Calculate discount
        Assert: Result is $0.00 (valid edge case)
        """
        # Arrange
        price = 0.0
        discount_percent = 50

        # Act
        result = calculate_discount(price, discount_percent)

        # Assert
        assert result == 0.0

    def test_very_small_price(self):
        """
        Test calculation with very small price (penny)

        Arrange: Set price=$0.01, discount=50%
        Act: Calculate discount
        Assert: Result is correctly rounded
        """
        # Arrange
        price = 0.01
        discount_percent = 50

        # Act
        result = calculate_discount(price, discount_percent)

        # Assert
        assert result == 0.01  # Rounded to 2 decimal places

    def test_large_price(self):
        """
        Test calculation with very large price

        Arrange: Set price=$1,000,000
        Act: Calculate discount
        Assert: Calculation works correctly for large numbers
        """
        # Arrange
        price = 1_000_000.0
        discount_percent = 10
        member_tier = "gold"

        # Act
        result = calculate_discount(price, discount_percent, member_tier)

        # Assert
        # $1M -> 10% off = $900K -> 10% tier bonus = $810K
        assert result == 810_000.0

    def test_price_with_many_decimals(self):
        """
        Test that result is properly rounded to 2 decimal places

        Arrange: Set price that will result in many decimal places
        Act: Calculate discount
        Assert: Result has exactly 2 decimal places
        """
        # Arrange
        price = 99.99
        discount_percent = 33
        member_tier = "silver"

        # Act
        result = calculate_discount(price, discount_percent, member_tier)

        # Assert
        assert isinstance(result, float)
        # Check that result has at most 2 decimal places
        assert result == round(result, 2)

    def test_boundary_discount_0_percent(self):
        """Test boundary: 0% discount"""
        assert calculate_discount(100, 0) == 100.0

    def test_boundary_discount_100_percent(self):
        """Test boundary: 100% discount"""
        assert calculate_discount(100, 100) == 0.0

    def test_default_tier_parameter(self):
        """
        Test that tier parameter defaults to 'regular'

        Arrange: Call function without tier parameter
        Act: Calculate discount
        Assert: Regular tier is used (no tier bonus)
        """
        # Act - don't pass tier parameter
        result = calculate_discount(100, 20)

        # Assert - should be same as regular tier
        expected = calculate_discount(100, 20, "regular")
        assert result == expected


class TestCalculateDiscountErrorHandling:
    """Test error handling and validation"""

    def test_negative_price_raises_error(self):
        """
        Test that negative price raises ValueError

        Arrange: Set price to negative value
        Act: Attempt to calculate discount
        Assert: ValueError is raised with appropriate message
        """
        # Arrange
        price = -10.0

        # Act & Assert
        with pytest.raises(ValueError) as exc_info:
            calculate_discount(price, 20)

        assert "Price cannot be negative" in str(exc_info.value)

    def test_negative_discount_raises_error(self):
        """
        Test that negative discount raises ValueError

        Arrange: Set discount to negative value
        Act: Attempt to calculate
        Assert: ValueError with appropriate message
        """
        # Arrange
        discount = -5

        # Act & Assert
        with pytest.raises(ValueError) as exc_info:
            calculate_discount(100, discount)

        assert "Discount must be between 0 and 100" in str(exc_info.value)

    def test_discount_over_100_raises_error(self):
        """
        Test that discount > 100% raises ValueError

        Arrange: Set discount above 100
        Act: Attempt to calculate
        Assert: ValueError with appropriate message
        """
        # Arrange
        discount = 150

        # Act & Assert
        with pytest.raises(ValueError) as exc_info:
            calculate_discount(100, discount)

        assert "Discount must be between 0 and 100" in str(exc_info.value)

    def test_discount_exactly_101_raises_error(self):
        """Test boundary: exactly 101% discount should fail"""
        with pytest.raises(ValueError):
            calculate_discount(100, 101)

    def test_invalid_tier_raises_error(self):
        """
        Test that invalid member tier raises ValueError

        Arrange: Set tier to invalid value
        Act: Attempt to calculate
        Assert: ValueError with tier name in message
        """
        # Arrange
        invalid_tier = "platinum"

        # Act & Assert
        with pytest.raises(ValueError) as exc_info:
            calculate_discount(100, 20, invalid_tier)

        assert "Invalid member tier" in str(exc_info.value)
        assert "platinum" in str(exc_info.value)

    def test_empty_string_tier_raises_error(self):
        """Test that empty string tier raises ValueError"""
        with pytest.raises(ValueError):
            calculate_discount(100, 20, "")

    def test_case_sensitive_tier(self):
        """
        Test that tier names are case-sensitive

        Arrange: Pass tier with wrong case
        Act: Attempt to calculate
        Assert: ValueError is raised (case matters)
        """
        with pytest.raises(ValueError):
            calculate_discount(100, 20, "Gold")  # Should be "gold"

        with pytest.raises(ValueError):
            calculate_discount(100, 20, "REGULAR")  # Should be "regular"


class TestCalculateDiscountTypeValidation:
    """Test type validation (if function adds type checking in future)"""

    def test_string_price_coercion(self):
        """
        Test behavior when price is passed as string

        Note: Currently Python will raise TypeError.
        If function adds type coercion, update this test.
        """
        # This test documents current behavior
        # If function adds input coercion, modify test accordingly
        with pytest.raises(TypeError):
            calculate_discount("100", 20)

    def test_string_discount_coercion(self):
        """Test behavior when discount is passed as string"""
        with pytest.raises(TypeError):
            calculate_discount(100, "20")

    def test_none_tier_raises_error(self):
        """Test that None tier raises appropriate error"""
        with pytest.raises((ValueError, TypeError)):
            calculate_discount(100, 20, None)


# ============================================================================
# PARAMETERIZED TESTS
# ============================================================================

class TestCalculateDiscountParameterized:
    """Parameterized tests for comprehensive coverage with less code"""

    @pytest.mark.parametrize("price,discount,tier,expected", [
        # (price, discount%, tier, expected_result)
        (100, 0, "regular", 100.0),
        (100, 10, "regular", 90.0),
        (100, 50, "regular", 50.0),
        (100, 100, "regular", 0.0),
        (100, 10, "silver", 85.5),   # 10% off = 90, then 5% tier = 85.5
        (100, 10, "gold", 81.0),     # 10% off = 90, then 10% tier = 81
        (50, 20, "silver", 38.0),    # 20% off = 40, then 5% tier = 38
        (200, 25, "gold", 135.0),    # 25% off = 150, then 10% tier = 135
    ])
    def test_various_combinations(self, price, discount, tier, expected):
        """Test various valid combinations of price, discount, and tier"""
        result = calculate_discount(price, discount, tier)
        assert result == expected

    @pytest.mark.parametrize("invalid_price", [
        -1, -0.01, -100, -1000000
    ])
    def test_various_negative_prices(self, invalid_price):
        """Test that all negative prices raise ValueError"""
        with pytest.raises(ValueError, match="Price cannot be negative"):
            calculate_discount(invalid_price, 20)

    @pytest.mark.parametrize("invalid_discount", [
        -1, -0.01, 101, 150, 1000
    ])
    def test_various_invalid_discounts(self, invalid_discount):
        """Test that out-of-range discounts raise ValueError"""
        with pytest.raises(ValueError, match="Discount must be between 0 and 100"):
            calculate_discount(100, invalid_discount)

    @pytest.mark.parametrize("invalid_tier", [
        "platinum", "bronze", "premium", "", "GOLD", "Regular"
    ])
    def test_various_invalid_tiers(self, invalid_tier):
        """Test that invalid tier names raise ValueError"""
        with pytest.raises(ValueError, match="Invalid member tier"):
            calculate_discount(100, 20, invalid_tier)


# ============================================================================
# FIXTURES FOR COMMON TEST DATA
# ============================================================================

@pytest.fixture
def standard_price():
    """Fixture providing standard test price"""
    return 100.0


@pytest.fixture
def valid_tiers():
    """Fixture providing list of valid tier values"""
    return ["regular", "silver", "gold"]


@pytest.fixture
def tier_bonus_map():
    """Fixture providing tier bonus percentages for verification"""
    return {
        "regular": 0,
        "silver": 5,
        "gold": 10
    }


class TestCalculateDiscountWithFixtures:
    """Tests using fixtures for reusable test data"""

    def test_all_tiers_valid(self, standard_price, valid_tiers):
        """Test that all valid tiers work without errors"""
        for tier in valid_tiers:
            result = calculate_discount(standard_price, 20, tier)
            assert isinstance(result, float)
            assert result > 0

    def test_tier_bonuses_correct(self, standard_price, tier_bonus_map):
        """Verify tier bonuses are applied correctly"""
        base_discount = 50  # 50% off

        for tier, bonus in tier_bonus_map.items():
            result = calculate_discount(standard_price, base_discount, tier)

            # Manual calculation
            after_discount = standard_price * (1 - base_discount / 100)
            expected = after_discount * (1 - bonus / 100)

            assert result == round(expected, 2)
